import yaml
from jinja2 import Environment, FileSystemLoader
import pathlib
import contextlib
import io
from functools import wraps
import logging
import os

def render_yaml_template(template_name, servers_path, vars={}):
    """
    Function in charge of generating file content based on:
    - a template file name, that template file must reside into data/templates.
    - path to the servers.yml file, this file must has been generated by
    - additional variables passed through vars.

    Generated content is returned.
    """
    # Load servers.yml content
    servers_file = open(servers_path, 'r')
    servers = yaml.load(servers_file, Loader=yaml.FullLoader)

    # Template directory is located in ./data/templates
    current_dir = pathlib.Path(__file__).parent.resolve()
    templates_dir = pathlib.PurePath.joinpath(current_dir, 'data/templates')

    file_loader = FileSystemLoader(str(templates_dir))
    env = Environment(loader=file_loader, trim_blocks=True)
    template = env.get_template(template_name)

    return template.render(servers=servers['servers'], vars=vars)

def load_yaml_file(filepath):
    try:
        file = open(filepath, 'r')
        variables = yaml.load(file, Loader=yaml.FullLoader)
        return variables
    except:
        raise 'Failed to load yaml file'

def build_inventory_yml(dest, servers_path, vars={}):
    inventory = render_yaml_template('inventory_v1.yml.j2', servers_path, vars)
    with open(dest, 'w') as f:
        f.write(inventory)


def build_config_yml(dest, servers_path, vars={}):
    config = render_yaml_template('config.yml.j2', servers_path, vars)
    with open(dest, 'w') as f:
        f.write(config)

def render_jinja_template(template_dir, template_name, vars: dict={}):
    '''
    Render a jinja template with dictionary unpacked.
    Ex. python -> jinja2 variable access: vars['key'] -> {{ key }}
    '''
    file_loader = FileSystemLoader(str(template_dir))
    env = Environment(loader=file_loader, trim_blocks=True)
    template = env.get_template(template_name)

    return template.render(**vars)

def build_preloaded_template(dest: pathlib.Path, vars: dict, template_name: str, mode=None):
    """
    A set of templates come loaded in ./data/templates for use
    """
    try:
        if pathlib.Path.is_dir(dest):
            dest = pathlib.PurePath.joinpath(dest, template_name.rstrip('.j2'))
        os.umask(0)
        if not mode and not pathlib.Path.exists(dest):
            mode = 0o640
        if not mode and pathlib.Path.exists(dest):
            mode = dest.stat().st_mode & 0o777

        current_dir = pathlib.Path(__file__).parent.resolve()
        template_dir = pathlib.PurePath.joinpath(current_dir, 'data/templates')
        rendered_file = render_jinja_template(template_dir, template_name, vars)
        with open(os.fspath(dest), 'w') as f:
            f.write(rendered_file)
        dest.chmod(mode)
    except:
        raise Exception('Cannot build preloaded template')

def build_vagrantfile(dest, vars={}, template_name='Vagrantfile.j2'):
    return build_preloaded_template(dest=pathlib.Path(dest), vars=vars, template_name=template_name)

def build_ansible_inventory(dest, vars={}, template_name='inventory.yml.j2'):
    return build_preloaded_template(dest=pathlib.Path(dest), vars=vars, template_name=template_name)

def build_add_host_sh(dest, vars={}, template_name='add_host.sh.j2'):
    return build_preloaded_template(dest=pathlib.Path(dest), vars=vars, template_name=template_name, mode=0o700)

def build_ssh_config(dest, vars={}, template_name='ssh_config.j2'):
    return build_preloaded_template(dest=pathlib.Path(dest), vars=vars, template_name=template_name, mode=0o600)

def redirect_io(func):
    '''
    Decorator to capture stdout from function calls
    which do not control their outputs properly.
    Instead we will send it to logging.debug
    '''
    @wraps(func)
    def wrapper(*args, **kwargs):
        result = None
        with io.StringIO() as captured_stdout:
            with contextlib.redirect_stdout(captured_stdout):
                result = func(*args, **kwargs)
                logging.debug(result)
                logging.debug(captured_stdout)
        return result
    return wrapper
